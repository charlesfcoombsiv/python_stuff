def roll_up_spans_snflk(indata, patid_var, startdate_var, enddate_var, gap, outdata, cur, xwhere='', cleanup=True):
    """roll_up_spans_snflk
       Rolls-up time spans on a Snowflake table.
       Will only keep rows where both startdate_var and enddate_var are NOT NULL.
    
    Paramters:
            indata               : (string) Full name of the Snowflake table to roll-up.
                                            Needs to include database, schema, and table.
            
            patid_var            : (string) Name of patient column on Snowflake table
            
            startdate_var        : (string) Name of start date column on Snowflake table.
            
            enddate_var          : (string) Name of end date column on Snowflake table.
            
            gap                  : (int) Allowable gap in between spans for them to be considered one span.
            
            outdata              : (string) Name of the Snowflake table that is created from the roll-up.
                                            Needs to include database, schema, and table.
                                            The table will have patid_var, span number, and start and 
                                            end date for the span.							
            
            cur                  : (cursor) Cursor with the Snowflake connection to the warehouse but not a specific database or schema.
                
            xwhere               : (string) (not required) Additional where statments.
											Useful to limit your indata table to specific criteria.
											Needs to start with 'AND'.
                                            
            cleanup              : (boolean: True,False) Keep working tables for debugging purposes.
    
    Returns:
            The function does not return anthing but instead makes a table designated by outdata.
    
    Example: roll_up_spans_snflk(indata='database.schema.PATIENT_ENROLLMENTS',
                                  patid_var='patient_token_2', 
                                  startdate_var='eligibility_start_date',
                                  enddate_var='eligibility_end_date', 
                                  gap=30,
                                  outdata='database.schema.ENROLL_SPANS',
                                  cur=cur, 
                                  xwhere = 'AND medical_coverage_indicator = TRUE')
    
    Author: Charles Coombs - 2021/07/20
    
    Update History:
            Date - Name
                What was updated.
                
    
    """
    
    from snowflake_custom import log_snflk
    
    ##########################
    # Setup variables
    ##########################
    # Split up outdata location to get a database and schema to put work tables in
    # since you need to have write access to a table.
    out_db_schema = outdata.split('.')[0] + "." + outdata.split('.')[1]
    
    ##########################
    # De-dup spans
    ##########################
    
    # Only pick records with both start and end date.
    cur.execute(""" CREATE OR REPLACE TABLE {}._dedup AS
                    SELECT DISTINCT {}, {}, {}
                    FROM {}
                    WHERE {} IS NOT NULL AND {} IS NOT NULL {}
                
                """.format(out_db_schema, patid_var, startdate_var, enddate_var, indata, startdate_var, enddate_var, xwhere))
                
    log_snflk(indata= "{}._dedup".format(out_db_schema), cur=cur, ptid=patid_var)
    
    ##########################
    # Roll-up spans
    ##########################
    
    # Nested spans, e.g
    # Row 1: 1/1  -> 3/31
    # Row 2: 1/10 -> 2/10 (Nested)
    # Row 3: 4/1  -> 5/31
    
    # Create span numbers based on gap length.
    # This is bad use of variables with .format(). Just use the variable name instead of a,b,c next time.
    cur.execute("""CREATE OR REPLACE TABLE {a}._spans AS
    
                    WITH enroll1 AS (
                        SELECT *,
                            max({b}) OVER (PARTITION BY {c}
                                    ORDER BY {d}, {e} ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) AS date_to_compare,
                            DATEDIFF(day,
                                    max({f}) OVER (PARTITION BY {g} ORDER BY {h}, {i} ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING),
                                    {j})
                                    AS diff
                        FROM {k}._dedup
                    )
    
                    SELECT *,
                        SUM(CASE
                                WHEN diff > {l} THEN 1
                                ELSE 0
                                END
                            ) OVER (PARTITION BY {m} ORDER BY {n}, {o})+1 AS span
                    FROM enroll1
                """.format(a=out_db_schema, b=enddate_var, c=patid_var, d=startdate_var, e= enddate_var, f=enddate_var, 
                            g=patid_var, h=startdate_var, i=enddate_var, j=startdate_var, 
                            k=out_db_schema, l=gap, m=patid_var, n=startdate_var, o=enddate_var ))
                
    log_snflk(indata= "{}._spans".format(out_db_schema), cur=cur, ptid=patid_var)
              
    ######################
    # Find min and max startdate and enddate respectively for each patient-span.
    ####################
    cur.execute(""" CREATE OR REPLACE TABLE {} AS
                    SELECT {}, span, MIN({}) AS {}, MAX({}) AS {}
                    FROM {}._spans
                    GROUP BY 1,2
                    ORDER BY 1,2
                    """.format(outdata, patid_var, startdate_var, startdate_var, enddate_var, enddate_var, out_db_schema))
    
    log_snflk(indata= outdata, cur=cur, ptid=patid_var)
              
    ######################
    # Clean-up
    ####################
    if cleanup == True:
        cur.execute("DROP TABLE {}._spans".format(out_db_schema))
        cur.execute("DROP TABLE {}._dedup".format(out_db_schema))
        

# indata = 'database.schema.PATIENT_ENROLLMENTS'
# patid_var = 'patient_token_2'
# startdate_var = 'eligibility_start_date'
# enddate_var = 'eligibility_end_date'
# gap = 30
# outdata = 'database.schema.ENROLL_SPANS'
# cur= cur
# xwhere = 'AND medical_coverage_indicator = TRUE'
# cleanup = True

    # 1002541    01/01/2005    02/28/2005
    # 1002541    01/01/2005    02/15/2005
    # 1002541    01/01/2005    02/28/2005
    # 1002541    01/10/2005    02/09/2005
    # 1002541    01/15/2005    01/20/2005
    # 1002541    01/25/2005    03/15/2005
    # 1002541    03/16/2005    05/31/2005
    # 1002541    04/01/2005    05/31/2005
    # 1002541    04/10/2005    04/20/2005
    # 1002541    06/10/2005    12/31/2005
    # 1007898    07/01/2020    12/31/2020
    # 1007898    06/30/2020    12/31/2021
    # 1007898    04/04/2022    09/30/2022
    # 1007898    10/05/2022    12/31/2022
    
# from snowflake.connector.pandas_tools import write_pandas

# df_ru_test = pd.read_excel("drive location \\rollup_test.xlsx", engine='openpyxl')

# df_ru_test = df_ru_test.rename(columns={"patid":"PATID", "startdate":"STARTDATE", "enddate":"ENDDATE"})

# df_ru_test["STARTDATE"] = df_ru_test["STARTDATE"].astype('string')
# df_ru_test["ENDDATE"] = df_ru_test["ENDDATE"].astype('string')

# cur.execute("CREATE OR REPLACE TABLE DATABASE.SCHEMA.TEST (\"PATID\" varchar, \"STARTDATE\" timestamp, \"ENDDATE\" timestamp)")

# success, nchunks, nrows, _ = write_pandas(conn=conn_prj, df=df_ru_test, table_name='RU_TEST')

# roll_up_spans_snflk(indata='database.schema.TEST',
#                                   patid_var='patid', startdate_var='startdate',
#                                   enddate_var='enddate', gap=30,
#                                   outdata='database.schema.TEST',
#                                   cur=cur, cleanup=False)
